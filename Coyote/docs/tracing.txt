
/*!
  \page tracing Tracing

  Coyote can create traces for various components. Those traces allow, for instance, to track the utilization of the L2, L2, NoC, etc.
  
  ======================================================================
  \section how_to_trace How to trace


  Coyote can create traces for various components. Those traces allow, for instance, to track the utilization of the L2, L2, NoC, etc. 
  Traces are generated by setting the parameter <code>meta.params.trace true</code> to the <code>coyote</code> executable. To define 
  particular events to be monitored, the parameter <code>meta.params.events_to_trace</code> can be added. For the latter parameter, 
  a list can be added for multiple events. Have a look at the <code>Logger.cpp</code> for the options (they are mentioned in the 
  variable <code>ev</code> in the methods). The following example traces the traffic (incoming and outgoing) from the NoC to the Memory Tile

  \code{.sh}
  ./coyote -c ../../configs/simple_arch.yml -p meta.params.cmd ../../apps/test/test_1cores -p top.arch.params.num_cores 1 -p 
  meta.params.enable_llc true -p meta.params.enable_smart_mcpu true -p meta.params.trace true -p meta.params.events_to_trace 
  "[mem_tile_noc_recv,mem_tile_noc_sent]" | tee test.txt
  \endcode

  A value of <code>any</code> as an event of interest indicates that the user wishes to record all available events.

  Timestamp-based event filtering is also possible by using the <code>trace_start_tick</code> and <code>trace_end_tick</code> 
  parameters to determine the tracing bounds.


  ================================================================================
  \section trace_format Trace File Format

    After executing spike, the traces are stored in a file called "trace". It is in the following format:
  
  \code{.sh}
      % head trace
      timestamp,core,pc,event_type,id,address
      2474,0,80001e80,mem_tile_noc_sent,0,0
      2539,0,80001eee,mem_tile_noc_recv,0,0
      2540,0,80001eee,mem_tile_noc_sent,0,0
      2602,0,80001ef6,mem_tile_noc_recv,0,0
      2603,0,80001ef6,mem_tile_noc_sent,0,0
      2666,0,80004000,mem_tile_noc_recv,0,0
      2667,0,80004000,mem_tile_noc_sent,0,0
      2667,0,80004000,mem_tile_llc_sent,0,80004000
      2668,0,80004000,mem_tile_llc_sent,0,80004040
      2669,0,80004000,mem_tile_llc_sent,0,80004080
      2670,0,80004000,mem_tile_llc_sent,0,800040c0
      2671,0,80004000,mem_tile_llc_sent,0,80004100
      2672,0,80004000,mem_tile_llc_sent,0,80004140
      2673,0,80004000,mem_tile_llc_sent,0,80004180
      2674,0,80004000,mem_tile_llc_sent,0,800041c0
  \endcode


    It is a comma separated list (CSV).
    1. The first column indicates the timestamp in clock cycles or nanoseconds (since Coyote assumes a clock of 1 GHz).
    2. The second column is the ID of the core.
    3. The third column represents the PC, if any, associated to the event (0 otherwise). However, the Memory Tile might generate its memory requests, which depend on a parent address. For instance, an indexed vector load, will have a base address to which the indices are added. That means, that new addresses are sent to the Memory Controller, which were not transmitted through the NoC. For the Memory Tile the third column always contains the parent address, while the fifth column contains the child address.
    4. Event name
    5. and 6. Additional information. For instance, in case of the Memory Tile the 6. column contains the child address of a request generated within the Memory Tile. The base address in this case is mentioned in column 3.
  
  ================================================================================
  \section visualization Trace Visualization

    The traces genrated by Coyote can be visualized using Paraver (https://tools.bsc.es/paraver). To convert the traces generated into the paraver format, ./trace2prv/m_trace.py</code> is part of the repository. The resulting Paraver Files can then be opened as traces in Paraver. This script takes the following arguments:

      m_trace.py [-h] [--output-dir OUTPUT_DIR] [--output-name OUTPUT_NAME] [--events-sorted] [--exe EXE] input

    If a binary is specified, the script will add events representing the address bounds for the code and data structures statically defined in the binary (e.g. matrix 'a' starts in address 0xABCD and ends in address 0xDEF0). This can be used when visualizing the trace to associate events to the data structures that they involve.

    The <code>paraver_cfgs</code> folder in the repo contains sample config files to produce paraver visualizations. A good starting point is file <code>following_an_instruction_through_memory.cfg</code> which produces several windows to do as the title of the cfg says (example below). 
    
    \image html paraver.png "Example paraver visualization"

    The files in <code>paraver_cfgs</code> are just examples. You can produce your own visualizations to explore traces using the paraver GUI and then save them to cfg files for later re-use.

*/
